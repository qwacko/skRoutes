import type { Plugin } from 'vite';
import { readFileSync, existsSync, readdirSync, statSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

interface SchemaDefinition {
  routePath: string;
  filePath: string;
  paramsSchema?: string;
  searchParamsSchema?: string;
  paramsSchemaCode?: string;
  searchParamsSchemaCode?: string;
}

export function skRoutesPlugin(): Plugin {
  let root: string;
  const CONFIG_FILE_PATH = 'src/lib/.generated/skroutes-config.ts';

  return {
    name: 'skroutes-plugin',
    configResolved(config) {
      root = config.root;
    },
    buildStart() {
      // Generate the config file at build start
      generateConfigFile();
    },
    async handleHotUpdate({ file, server }) {
      // Regenerate config when page files change
      if (file.includes('+page.') && (file.endsWith('.ts') || file.endsWith('.js'))) {
        generateConfigFile();
        // Trigger module update for auto-skroutes
        const autoSkroutesModule = await server.moduleGraph.getModuleByUrl('/src/lib/auto-skroutes.ts');
        if (autoSkroutesModule) {
          server.reloadModule(autoSkroutesModule);
        }
      }
    }
  };

  function generateConfigFile(): void {
    const configContent = generateConfigModule();
    const configPath = join(root, CONFIG_FILE_PATH);
    
    // Ensure directory exists
    const configDir = join(root, 'src/lib/.generated');
    if (!existsSync(configDir)) {
      mkdirSync(configDir, { recursive: true });
    }
    
    writeFileSync(configPath, configContent, 'utf-8');
  }

  function generateConfigModule(): string {
    const schemas = scanForSchemas();
    
    const schemaDefinitions: string[] = [];
    const configEntries: string[] = [];

    // First, we need to add zod import since most schemas will use it
    const needsZodImport = schemas.some(s => 
      s.paramsSchemaCode?.includes('z.') || s.searchParamsSchemaCode?.includes('z.')
    );

    schemas.forEach((schema, index) => {
      const schemaAlias = `schema${index}`;
      
      // Define inline schemas to avoid import cycles
      if (schema.paramsSchemaCode) {
        schemaDefinitions.push(`const ${schemaAlias}_params = ${schema.paramsSchemaCode};`);
      }
      if (schema.searchParamsSchemaCode) {
        schemaDefinitions.push(`const ${schemaAlias}_searchParams = ${schema.searchParamsSchemaCode};`);
      }

      const entry = `'${schema.routePath}': {
        ${schema.paramsSchemaCode ? `paramsValidation: ${schemaAlias}_params,` : ''}
        ${schema.searchParamsSchemaCode ? `searchParamsValidation: ${schemaAlias}_searchParams,` : ''}
      }`;
      
      configEntries.push(entry);
    });

    // Generate type-safe route keys and type mapping
    const routeKeys = schemas.map(s => `'${s.routePath}'`).join(' | ');
    
    // Generate type mappings for each route
    const typeMapping = schemas.map((schema, index) => {
      const schemaAlias = `schema${index}`;
      const paramsType = schema.paramsSchemaCode 
        ? `StandardSchemaV1.InferOutput<typeof ${schemaAlias}_params>`
        : 'undefined';
      const searchParamsType = schema.searchParamsSchemaCode
        ? `StandardSchemaV1.InferOutput<typeof ${schemaAlias}_searchParams>`
        : 'undefined';
      
      return `  '${schema.routePath}': { params: ${paramsType}; searchParams: ${searchParamsType} }`;
    }).join(';\n');
    
    return `// Auto-generated by skroutes-plugin
import type { StandardSchemaV1 } from '@standard-schema/spec';
${needsZodImport ? "import { z } from 'zod';" : ''}

// Inline schema definitions (extracted from page files)
${schemaDefinitions.join('\n')}

export const routeConfig = {
  ${configEntries.join(',\n  ')}
} as const;

// Export route keys for type checking
export type RouteKeys = ${routeKeys || 'never'};

// Export type mapping for schema inference
export type RouteTypeMap = {
${typeMapping}
};

// Re-export types for convenience
export type { RouteConfig } from '../skRoutes-v2.js';
`;
  }

  function scanForSchemas(): SchemaDefinition[] {
    const schemas: SchemaDefinition[] = [];
    const routesDir = join(root, 'src/routes');
    
    function walkDirectory(dir: string, relativePath = ''): void {
      if (!existsSync(dir)) return;
      
      const entries = readdirSync(dir);
      
      for (const entry of entries) {
        const fullPath = join(dir, entry);
        const stat = statSync(fullPath);
        
        if (stat.isDirectory()) {
          walkDirectory(fullPath, join(relativePath, entry));
        } else if (entry.match(/^\+page\.(server\.)?ts$/)) {
          const content = readFileSync(fullPath, 'utf-8');
          const routePath = extractRoutePathFromDirectory(relativePath);
          
          // Look for underscore-prefixed schema exports and extract their code
          const paramsMatch = content.match(/export\s+const\s+_paramsSchema\s*=\s*([^;]+);/);
          const searchParamsMatch = content.match(/export\s+const\s+_searchParamsSchema\s*=\s*([^;]+);/);

          if (paramsMatch || searchParamsMatch) {
            schemas.push({
              routePath,
              filePath: fullPath,
              paramsSchema: paramsMatch ? '_paramsSchema' : undefined,
              searchParamsSchema: searchParamsMatch ? '_searchParamsSchema' : undefined,
              paramsSchemaCode: paramsMatch ? paramsMatch[1].trim() : undefined,
              searchParamsSchemaCode: searchParamsMatch ? searchParamsMatch[1].trim() : undefined
            });
          }
        }
      }
    }
    
    walkDirectory(routesDir);
    return schemas;
  }

  function extractRoutePathFromDirectory(relativePath: string): string {
    // Convert directory path to SvelteKit route path
    if (!relativePath || relativePath === '') return '/';
    
    let routePath = '/' + relativePath.replace(/\\/g, '/');
    
    // Ensure no trailing slash except for root
    if (routePath !== '/' && routePath.endsWith('/')) {
      routePath = routePath.slice(0, -1);
    }
    
    return routePath;
  }
}